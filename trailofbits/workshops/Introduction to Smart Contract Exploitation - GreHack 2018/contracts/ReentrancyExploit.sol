pragma solidity ^0.4.24;

// ABI of the target
contract ReentrancyABI {
   function addToBalance() payable public;
   function withdrawBalance() public;
}


contract ReentrancyExploit {
  bool attack_is_on=false; // set to true when the attack is on
  ReentrancyABI vulnerable_contract;
  address owner;


  constructor() public{
      owner = msg.sender;
  }


  // Depose some ether to the target 
  // And save the target address
  function deposit(ReentrancyABI _vulnerable_contract) public payable{
      vulnerable_contract = _vulnerable_contract ;
      vulnerable_contract.addToBalance.value(msg.value)();
  }

  // This function will launch the attack
  function launch_attack() public{
      // You must set attack_is_on to true
      // and call the withdrawBalance function of the target
  }
 
  // fallback function
  // This is the function executed when a transaction is sent to
  // the contract
  function () public payable{
      // You must check that the attack is ongoing
      // If it is, re-call the withdrawBalance of the target
      // and set attack_is_on to false to prevent an infinite loop
  }

  // Withdraw the money
  // This function will be call after the attack, to get the money
  function get_money() public{
      owner.transfer(address(this).balance);
  }
}

